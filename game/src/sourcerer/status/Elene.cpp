/***********************************************************************//**
 *	Elene.cpp
 *	Enlight Game Application
 *
 *	Created by Ryoutarou Kishi on 2010/01/29.
 *	Copyright 2010 Altoterras Corporation. All rights reserved.
 *
**//***********************************************************************/

////////////////////////////////////////////////////////////////////////////
// インクルードファイル

// Base

// Self
#include "Elene.h"

// Friends

// External

// Library

////////////////////////////////////////////////////////////////////////////

SRCR_BEGIN_NS

////////////////////////////////////////////////////////////////////////////
// クラス

//==========================================================================
// Elene メソッド

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// アクセサ

/*---------------------------------------------------------------------*//**
	初期値（全てゼロ）かどうかを得る
**//*---------------------------------------------------------------------*/
bool Elene::isInitialValue() const
{
	for(int i = 0; i < Elene::NUM_EL; i++)
	{
		if(_ee[i] != 0)	{	return false;	}
	}
	return true;
}

/*---------------------------------------------------------------------*//**
	物理スコアを得る
	※ 計算式詳細は『ソウマ関数と計算式.odt』参照のこと
**//*---------------------------------------------------------------------*/
s32 Elene::getMaterialScore() const
{
	return ((_ee[EL_SO] * 3) + _ee[EL_WA]) >> 2;
}

/*---------------------------------------------------------------------*//**
	物理率を得る
	※ 計算式詳細は『ソウマ関数と計算式.odt』参照のこと
**//*---------------------------------------------------------------------*/
f32 Elene::getMaterialRatio() const
{
	f32 s = (f32)(((_ee[EL_SO] * 3) + _ee[EL_WA]) >> 2);
	s = s / (f32)(_ee[EL_AE] >> 1);
	if(s > 1.0f) { s = 1.0f; }
	return s;
}

/*---------------------------------------------------------------------*//**
	エネルギースコアを得る
	※ 計算式詳細は『ソウマ関数と計算式.odt』参照のこと
**//*---------------------------------------------------------------------*/
s32 Elene::getEngyScore() const
{
	return (_ee[EL_WA] >> 3) + ((_ee[EL_FI] * 3) >> 3) + (_ee[EL_WI] >> 1);
}

/*---------------------------------------------------------------------*//**
	エネルギー率を得る
	※ 計算式詳細は『ソウマ関数と計算式.odt』参照のこと
**//*---------------------------------------------------------------------*/
f32 Elene::getEngyRatio() const
{
	f32 s = (f32)((_ee[EL_WA] >> 3) + ((_ee[EL_FI] * 3) >> 3) + (_ee[EL_WI] >> 1));
	s = s / (f32)_ee[EL_AE];
	if(s > 1.0f) { s = 1.0f; }
	return s;
}

/*---------------------------------------------------------------------*//**
	重さ [g]（グラム）を得る
	※ 計算式詳細は『ソウマ関数と計算式.odt』参照のこと
**//*---------------------------------------------------------------------*/
s32 Elene::getWeight() const
{
	s32 wMat = ((_ee[EL_SO] * 3) >> 2) + (_ee[EL_WA] >> 2);	// 物質スコア
	s32 wEne = (_ee[EL_AE] > 0) ? ( ((_ee[EL_WA] >> 3) + ((_ee[EL_FI] * 3) >> 3) + (_ee[EL_WI] >> 1)) / _ee[EL_AE] ) : 0;
	s32 wMin = wMat >> 9;
	s32 w = (wMat - (wEne >> 1)) >> 1;
	if(w < wMin) { w = wMin; }
	return w;
}

/*---------------------------------------------------------------------*//**
	体積 [l]（リットル）を得る
	※ 計算式詳細は『ソウマ関数と計算式.odt』参照のこと
**//*---------------------------------------------------------------------*/
s32 Elene::getVolume() const
{
	return _ee[EL_AE] >> 10;	// ÷ 1024
}

/*---------------------------------------------------------------------*//**
	有効半径を得る
	※ 計算式詳細は『ソウマ関数と計算式.odt』参照のこと
**//*---------------------------------------------------------------------*/
f32 Elene::getEffectiveRange() const
{
	return (_ee[EL_AE] << 1) / (f32)Elene::ELENE_VALID_FIGURE;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// 外部サービス

/*---------------------------------------------------------------------*//**
	同一判定
**//*---------------------------------------------------------------------*/
bool Elene::equals(const Elene* s) const
{
	for(int i = 0; i < NUM_EL; i++)
	{
		if(_ee[i] != s->_ee[i])
		{
			return false;
		}
	}
	return true;
}

/*---------------------------------------------------------------------*//**
	全体シフト処理
**//*---------------------------------------------------------------------*/
void Elene::shift(Elene* res, s32 shiftval) const
{
	if(shiftval > 0)
	{
		do
		{
			for(int i = 0; i < Elene::NUM_EL; i++)
			{
				s32 valMv = (_ee[i] >= shiftval) ? shiftval : _ee[i];
				res->_ee[i] = _ee[i] - valMv;
				if((i + 1) < Elene::NUM_EL)
				{
					s32 valNw = _ee[i + 1] + valMv;
					if(valNw > ELEN_MAX)	{	valNw = ELEN_MAX;	}
					res->_ee[i + 1] = valNw;
				}
			}
			shiftval -= SHIFT_STDVAL;
		}
		while(shiftval > 0);
	}
	else if(shiftval < 0)
	{
		shiftval = -shiftval;
		do
		{
			for(int i = Elene::NUM_EL - 1; i >= 0; i--)
			{
				s32 valMv = (_ee[i] >= shiftval) ? shiftval : _ee[i];
				res->_ee[i] = _ee[i] - valMv;
				if((i - 1) >= 0)
				{
					s32 valNw = _ee[i - 1] + valMv;
					if(valNw > ELEN_MAX)	{	valNw = ELEN_MAX;	}
					res->_ee[i - 1] = valNw;
				}
			}
			shiftval -= SHIFT_STDVAL;
		}
		while(shiftval > 0);
	}
}

/*---------------------------------------------------------------------*//**
	ソウマ実体化時の生命エネルギー消費量を得る
	※ 計算式詳細は『ソウマ関数と計算式.odt』参照のこと
**//*---------------------------------------------------------------------*/
s32 Elene::getSoumaMaterializeLifeEnergy() const
{
	// 基本計算
	s32 lfene =
		(_ee[EL_AE] / 4) +		// ÷ 4
		(_ee[EL_WI] / 8) +		// ÷ 8
		(_ee[EL_FI] / 16) +		// ÷ 16
		(_ee[EL_WA] / 32) +		// ÷ 32
		(_ee[EL_SO] / 64);		// ÷ 64

	// 属性元素は特殊効果が付与され、より多くのエネルギーを消費する
	s32 ae2t = _ee[EL_AE] * 2;
#if 1	// ［2012/08/23 r-kishi］お試し
	/*
	if(_ee[EL_SO] >= ae2t)	{	lfene += _ee[EL_SO] / 64;	}
	if(_ee[EL_WA] >= ae2t)	{	lfene += _ee[EL_WA] / 64;	}
	if(_ee[EL_FI] >= ae2t)	{	lfene += _ee[EL_FI] / 64;	}
	if(_ee[EL_WI] >= ae2t)	{	lfene += _ee[EL_WI] / 64;	}
	 */
	/*
	if(_ee[EL_SO] >= ae2t)	{	lfene += _ee[EL_SO] / 128;	}
	if(_ee[EL_WA] >= ae2t)	{	lfene += _ee[EL_WA] / 128;	}
	if(_ee[EL_FI] >= ae2t)	{	lfene += _ee[EL_FI] / 128;	}
	if(_ee[EL_WI] >= ae2t)	{	lfene += _ee[EL_WI] / 128;	}
	 */
#else
	if(_ee[EL_SO] >= ae2t)	{	lfene += _ee[EL_SO] / 32;	}
	if(_ee[EL_WA] >= ae2t)	{	lfene += _ee[EL_WA] / 16;	}
	if(_ee[EL_FI] >= ae2t)	{	lfene += _ee[EL_FI] / 8;	}
	if(_ee[EL_WI] >= ae2t)	{	lfene += _ee[EL_WI] / 4;	}
#endif

	return lfene;
}

/*---------------------------------------------------------------------*//**
	スケーリング - 100 を等倍とした整数演算
**//*---------------------------------------------------------------------*/
void Elene::scale(s32 ratio)
{
	for(int i = 0; i < Elene::NUM_EL; i++)
	{
		_ee[i] = _ee[i] * 100 / ratio;
	}
}

/*---------------------------------------------------------------------*//**
	スケーリング - 1.0f を等倍とした浮動小数点演算
**//*---------------------------------------------------------------------*/
void Elene::scale(f32 ratio)
{
	for(int i = 0; i < Elene::NUM_EL; i++)
	{
		_ee[i] = (s32)(_ee[i] * ratio);
	}
}

#if defined(_DEBUG)
/*---------------------------------------------------------------------*//**
	デバッグ出力
**//*---------------------------------------------------------------------*/
void Elene::_debug_traceValue()
{
	TRACE("{%d,%d,%d,%d,%d}", _ee[0], _ee[1], _ee[2], _ee[3], _ee[4]);
}
#endif

////////////////////////////////////////////////////////////////////////////

SRCR_END_NS
