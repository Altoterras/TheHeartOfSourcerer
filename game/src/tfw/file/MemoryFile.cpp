/***********************************************************************//**
 *	MemoryFile.cpp
 *	Terras Framework
 *
 *	Created by Ryoutarou Kishi on 2009/07/29.
 *	Copyright 2009 Altoterras Corporation. All rights reserved.
 *
**//***********************************************************************/

////////////////////////////////////////////////////////////////////////////
// インクルードファイル

// Base

// Self
#include "MemoryFile.h"

// Friends
#include "../string/VcString.h"

// External

// Library

////////////////////////////////////////////////////////////////////////////

TFW_BEGIN_NS

////////////////////////////////////////////////////////////////////////////
// クラス

//==========================================================================
// MemoryFile メソッド

/*---------------------------------------------------------------------*//**
	コンストラクタ
**//*---------------------------------------------------------------------*/
MemoryFile::MemoryFile() : _bufRead(0L), _bufWrite(0L), _sizeBuf(0), _idxPos(0)
{
}

/*---------------------------------------------------------------------*//**
	コンストラクタ
**//*---------------------------------------------------------------------*/
MemoryFile::MemoryFile(const char* buf, u32 size) : _bufRead(0L), _bufWrite(0L), _sizeBuf(0), _idxPos(0)
{
	open(buf, size);
}

/*---------------------------------------------------------------------*//**
	コンストラクタ
**//*---------------------------------------------------------------------*/
MemoryFile::MemoryFile(char* buf, u32 size) : _bufRead(0L), _bufWrite(0L), _sizeBuf(0), _idxPos(0)
{
	open(buf, size);
}

/*---------------------------------------------------------------------*//**
	デストラクタ
**//*---------------------------------------------------------------------*/
MemoryFile::~MemoryFile()
{
}

/*---------------------------------------------------------------------*//**
	ファイルを読み込み専用で開く
**//*---------------------------------------------------------------------*/
bool MemoryFile::open(const char* buf, u32 size)
{
	_bufRead = buf;
	_sizeBuf = size;
	return true;
}

/*---------------------------------------------------------------------*//**
	ファイルを書き込み専用で開く
**//*---------------------------------------------------------------------*/
bool MemoryFile::open(char* buf, u32 size)
{
	_bufWrite = buf;
	_sizeBuf = size;
	return true;
}

/*---------------------------------------------------------------------*//**
	ファイルを閉じる
**//*---------------------------------------------------------------------*/
void MemoryFile::close()
{
	_bufRead = 0L;
	_bufWrite = 0L;
	_sizeBuf = 0;
}

/*---------------------------------------------------------------------*//**
	読み込む
**//*---------------------------------------------------------------------*/
u32 MemoryFile::read(void* buf, u32 size)
{
	if(_bufRead == 0L)	{	return 0;	}

	u32 sizeRead = TFW_MIN(size, _sizeBuf - _idxPos);
	::memcpy(buf, &_bufRead[_idxPos], sizeRead);
	_idxPos += sizeRead;
	return sizeRead;
}

/*---------------------------------------------------------------------*//**
	文字列に読み込む
**//*---------------------------------------------------------------------*/
u32 MemoryFile::readString(VcString* str, u32 size)
{
	char* buf = new char[size];
	if(buf == 0)	{	return 0;	}

	u32 sizeRead = read(buf, size);
	if(sizeRead > 0)
	{
		str->set(buf, sizeRead);
	}
	else
	{
		str->set("");
	}

	return sizeRead;
}

/*---------------------------------------------------------------------*//**
	テキストを１行読み込む

	@retval true 読み込み成功
	@retval false 読み込みが終了した
**//*---------------------------------------------------------------------*/
bool MemoryFile::readTextLine(VcString* str)
{
	char c;
	VcString strWk;

	while(read(&c, 1) == 1)
	{
		if(c == '\r')
		{
		}
		else if(c == '\n')
		{
			*str = strWk;
			return true;
		}
		else
		{
			strWk += c;
		}
	}
	
	if(strWk.getLength() > 0)
	{
		*str = strWk;
		return true;
	}

	return false;
}

/*---------------------------------------------------------------------*//**
	書き込む
**//*---------------------------------------------------------------------*/
u32 MemoryFile::write(const void* buf, u32 size)
{
	if(_bufWrite == 0L)	{	return 0;	}

	u32 sizeWrite = TFW_MIN(size, _sizeBuf - _idxPos);
	::memcpy(&_bufWrite[_idxPos], buf, sizeWrite);
	_idxPos += sizeWrite;
	return sizeWrite;
}

/*---------------------------------------------------------------------*//**
	文字列を書き込む
**//*---------------------------------------------------------------------*/
u32 MemoryFile::writeString(const CStringBase* str)
{
	return write(str->getRaw(), str->getLength());
}

/*---------------------------------------------------------------------*//**
	シーク
**//*---------------------------------------------------------------------*/
void MemoryFile::seek(u32 offset, bool isTop)
{
	if(isTop)	{	_idxPos = offset;	}
	else		{	_idxPos += offset;	}
}

/*---------------------------------------------------------------------*//**
	現在のシーク位置を得る
**//*---------------------------------------------------------------------*/
u32 MemoryFile::getPosition() const
{
	return _idxPos;
}

/*---------------------------------------------------------------------*//**
	フラッシュ
**//*---------------------------------------------------------------------*/
void MemoryFile::flush()
{
	// 何もしない
}

/*---------------------------------------------------------------------*//**
	ファイルサイズを得る
**//*---------------------------------------------------------------------*/
u32 MemoryFile::getLength() const
{
	return _sizeBuf;
}

////////////////////////////////////////////////////////////////////////////

TFW_END_NS
