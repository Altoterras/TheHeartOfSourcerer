【命名規則】

init
	・クラスやモジュールを初期化する処理で、
	　基本的にアプリ内で一度きり実行されるもの（ある意味静的）
	⇔ cleanup

create
	・オブジェクトを使えるようにするための生成処理
	・作成しつつ内部で自身を保持するもの
	⇔ destroy

begin
	・ある実装の前後に挟むような処理の前の部分
	⇔ end

make
	・ある複雑な処理の結果に生成されるもの
	・返り値は生成されたオブジェクトのポインタ（や参照）

load
	・ファイルやネットワークなどのデバイスを経由して生成されるもの
	・返り値は生成されたオブジェクトのポインタ（や参照）

new
	・単純な処理（メモリ確保等）により生成されるもの
	・返り値は生成されたオブジェクトのポインタ（や参照）
	⇔ delete

set
	・対象オブジェクトの内容そのものを変更して指示された状態にする
	・返り値は void か自身のポインタ（や参照）


【オブジェクトの生成・破棄】

・コンストラクタ
	初期値代入とメモリの確保のみ
	メモリ確保以外の失敗しうる処理は行わない
	コンストラクタ実行のみで使用できるオブジェクトは非常に単純なものとする
	
・create
	生成処理や初期化
	create 実行後は基本的に使用可能
	
・destroy
	後処理
	destroy 実行後は基本的に使用不可能
	
・デストラクタ
	メモリの解放と初期値戻し
	Java などのガベージベースのシステムはデストラクタがないため、ここに重要な後処理は書かない


【ポインタと参照】

・原則としてポインタを使用する。

C++ においてはクラスインスタンスを指し示すものとしてポインタと参照が存在するが、
本プロジェクトにおいては Java や C# への機械的変換を検討しているので、ポインタを全面的に利用する。
記述上は参照の方が近い感じはあるが、new や null の概念的にはポインタの方が自動変換しやすい。
ただし、C++ の言語仕様上、コピーコンストラクタや operator などには参照の方が親和性が高いので、
これらの記述に対しては参照を用いる。
（operator が機会変換上好ましいかどうかは後述する。）

関数内のローカル変数（スタック変数）に関しては、全て new/delete するのは手間とメモリリークの危険性、
try/catch との親和性を著しく損なうので、ヒープを使わないことも良しとする。

また、変換コンストラクタなど、C++ 特有の言語仕様である可能性が高いものに関しては、
explicit 演算子などを利用してなるべく依存しないようにする。
（ただし、文字列は Java/C# でも特殊な扱いになるので例外。）


【プロパティと外部サービス】

メソッドには「プロパティ」と「外部サービス」の２種類を分類していあるが、以下のような基準で分けている

・プロパティ
　・get と set が対になることが想像できる（なるのが好ましいかは別として）
　・基本的に代入や return のみで処理が終わる（変数を public にしたものに近い）
　・処理時間としては最小のものとして考えられる

・外部サービス
　・複雑な処理を行うもの
　・処理時間はそれなりにかかるものと考えられる

将来的な実装を踏まえて分けること

